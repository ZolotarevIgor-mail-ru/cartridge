Консистентный свичовер не зависит от режима фейловера. Это две
ортогональные фичи, хотя обе они используют внешний координатор.
С появлением консистентного свичовера к фейловеру можно относиться как
к неконсистентному автоматическому промоуту.

При консистентном свичовере каждый инстанс защищается от
преждевременного перехода в состояние rw. Инстанс, который вправе вести
запись мы будем называть [vclockkeeper](https://en.wikipedia.org/wiki/Clockkeeper)
(люблю каламбур, см. также https://hanakokun.fandom.com/wiki/No.1_The_Clock_Keepers).

Для этого используется тот же самый внешний стейт провайдер. В нём
хранятся записи вида `replicaset_uuid, instance_uuid, vclock`.

После назначения инстанса новым лидером, он выполняет `wait_lsn`
относительно vclockkeeper. Когда у него получится, он перезаписывает
себя в качестве нового vclockkeeper. Реально переход в rw происходит
только после синхронизации и после успешной записи текущего vclock во
внешнее хранилище.

Vclock в данном описании нужен больше для аудита, чем для чего-либо ещё.

Если во внешнем хранилище отсутствует информация о vclockkeeper,
то wait_lsn выполняется относительно всех членов репликасета.

Если во внешнем хранилище есть vclockkeeper, но для него неизвестен
vclock, то wait_lsn не выполняется, любой лидер при желании может взять
лидерство неконсистентно.

При срабатывании фейловера координатор самостоятельно записывает vclock
назначаемого инстанса.

### FAQ

Q: В каких случаях консистентный свичовер может обломаться? И какие
   будут последствия?
A: В disabled режиме новый лидер может не успеть догнать старого, если
   старый лидер упадёт вскоре после переключения. Тогда мы останемся
   без лидера. Дальше мы либо починим старого лидера, либо придётся его
   дизейблить / экспелить.

Q: А если фейловер включён?
A: В stateful режиме преждевременная смерть старого лидера приведёт к
   срабатыванию настоящего фейловера, неконсистентного. Ожидание lsnов
   оборвётся и новый лидер принудительно перейдёт в rw.

Q: Ну а как работает консистентный промоут с eventual фейловером?
A: Как-то средне. Если приоритет лидеров меняется с двухфазным комитом,
   то инстанс попытается дождаться lsn. Но eventual фейловер очень
   капризный. Любое срабатывание фейловера прервёт ожидание.

Q: А что, если ожидание lsn займёт слишком много времени? Например
   если репликация сдохла?
A: Это жопа независимо от того включен консистентный промоут или нет.
   Новый лидер попробует дождаться синка, у него не получится. В таком
   случае можно либо переключить лидера обратно и попытаться починить
   репликацию, либо смириться с неконсистентностью и заказать лубрикант.

### Вопросы для обсуждения

1. Сейчас уже есть ручной промоут при стейтфул феловере (на сегодняшний
   день неконсистентный, очевидно). Должен ли он стать консистентным или
   у нас должен остаться выбор?

Идеи на будущее:

1. С данной архитектурой у нас есть возможность реализовать ещё один
   режим фейловера: ручной. От стейтфула он будет отличаться только тем,
   что никакие решения не будут приниматься автоматически (кроме первого
   назначения лидеров, пожалуй). Зато переключить лидеров можно будет
   даже при отсутствии кворума, при условии что координатор жив.

1. При текущей реализации ручное переключение лидера возможно только при
   наличии активного координатора. От этого ограничения не сложно
   избавиться, если оно кому-то мешает. Инстанс с вебмордой может сам
   захватить лок, запромоутить кого надо и тут же отпустить.

1. На сегодняшний день форматирование стейтборда сопряжено с
   переключением лидера на первого по приоритету, даже если в стейтборде
   хранилось другое значение. Даже если мы реализуем сейчас консистентное
   переключение лидеров, данный кейс всё равно останется неконсистентным.
   Мы можем это исправить и перепроверять состояние всех инстансов даже
   после форматирования стейтборда.
